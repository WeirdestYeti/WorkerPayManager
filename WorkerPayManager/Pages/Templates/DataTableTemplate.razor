
@typeparam TItem

<div class="row">
    <div class="col-4">
        <div class="form-inline">
            <label class="my-1 mr-2">Show</label>
            <select class="form-control form-control-sm" @onchange="showRowsSelectionChange">
                <option>10</option>
                <option>25</option>
                <option>50</option>
                <option>100</option>
            </select>
        </div>
    </div>
    <div class="col-6"></div>
    <div class="col-2">
        <div class="input-group mb-3 input-group-sm">
            <input type="text" class="form-control" placeholder="Search..." aria-label="Search..." aria-describedby="button-addon2">
            <div class="input-group-append">
                <button class="btn btn-info" type="button" id="button-addon2">Search</button>
            </div>
        </div>
    </div>
</div>

<table class="@TableClass">
    <thead class="@HeaderClass">
        <tr>
            @if (UseRowCount)
            {
                <th>#</th>
            }
            @for (int i = 0; i < PropertiesList.Count; i++)
            {
                if (PropertiesList[i].Item1 != null)
                {
                    int tempInt = i;
                    <th @onclick="(() => OrderByProperty(tempInt, PropertiesList[tempInt].Item1))">@PropertiesList[tempInt].Item2 @GetSortedByArrow(_headerSort[tempInt])</th>
                }
                else
                {
                    <th>@PropertiesList[i].Item2</th>
                }
            }
        </tr>
    </thead>
    <tbody>
        @foreach (var item in _listToShow)
        {
            <tr>
                @if (UseRowCount)
                {
                    _rowCount++;
                    <td>@(_rowCount + _skip)</td>
                }
                @RowTemplate(item)
            </tr>
        }
    </tbody>
    <tfoot>
        <tr>@TableFooter</tr>
    </tfoot>
</table>



<div class="row">
    <div class="col-4">
        <div role="status" aria-live="polite">
            Showing @(((_currentPage-1) * ShowRecords) + 1) to @(_maxPages == _currentPage ? Items.Count : ((_currentPage - 1) * ShowRecords) + ShowRecords) of @Items.Count entries
        </div>
    </div>
    <div class="col-8">
        <nav aria-label="Page navigation example">
            <ul class="pagination justify-content-end">
                <li class="page-item @(_currentPage == 1 ? "disabled" : "")">
                    <a class="page-link" @onclick="(() => SwitchPage(_currentPage - 1))" href="" @onclick:preventDefault tabindex="-1">Previous</a>
                </li>
                @for (int i = 1; i < _maxPages + 1; i++)
                {
                    int tempInt = i;
                    <li class="page-item @(_currentPage == i ? "active" : "")">
                        <a href="" class="page-link" @onclick="(() => SwitchPage(tempInt))" @onclick:preventDefault>@i</a>
                    </li>
                }
                <li class="page-item @(_currentPage == _maxPages ? "disabled" : "")">
                    <a class="page-link" @onclick="(() => SwitchPage(_currentPage + 1))" href="" @onclick:preventDefault>Next</a>
                </li>
            </ul>
        </nav>
    </div>
</div>



@*
    Dynamic sortable table template
    Usage: Same as TableTamplate but you need to add a list of properties togheter,
    with header names which are the same type of Items passed thru.
    Type is a List of Tuple with Func and a string = List<(Func<dynamic, IComparable>, string)>

    If you want a non sortable table header, then as first Tuple param pass NULL.

    Example:

    List<(Func<dynamic, IComparable>, string)> propertiesList = new List<(Func<dynamic, IComparable>, string)>();
    propertiesList.Add((x => x.FirstName, "First Name"));
    propertiesList.Add((x => x.LastName, "Last Name"));
    propertiesList.Add((null, "Action"));
*@

@code {

    // Pagination Start

    [Parameter]
    public int ShowRecords { get; set; }

    private int _skip { get; set; }

    private int _currentPage { get; set; }
    private int _maxPages
    {
        get
        {
            return (Items.Count / ShowRecords) + 1;
        }
    }

    private void SwitchPage(int toPage)
    {
        if(!(toPage < 1) && !(toPage > _maxPages))
        {
            _currentPage = toPage;
        }
        GetItemsToShow();
    }

    private void showRowsSelectionChange(ChangeEventArgs e)
    {
        int selection;
        bool result = Int32.TryParse(e.Value.ToString(), out selection);
        if(result)
        {
            ShowRecords = selection;
            _currentPage = 1;
            GetItemsToShow();
        }
    }
    // Pagination End

    private List<TItem> _listToShow { get; set; }

    [Parameter]
    public List<(Func<dynamic, IComparable>, string)> PropertiesList { get; set; }

    private List<SortArrows> _headerSort { get; set; }

    protected override void OnParametersSet()
    {
        _headerSort = new List<SortArrows>();
        for (int i = 0; i < PropertiesList.Count; i++)
        {
            _headerSort.Add(SortArrows.UpAndDown);
        }
        _currentPage = 1;

        // 
        GetItemsToShow();
    }

    public void GetItemsToShow()
    {

        _skip = (_currentPage - 1) * ShowRecords;

        _listToShow = Items.Skip(_skip).Take(ShowRecords).ToList();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        _rowCount = 0;
    }

    private void OrderByProperty(int headearId, Func<dynamic, IComparable> getProp)
    {
        if (_headerSort[headearId] == SortArrows.Down || _headerSort[headearId] == SortArrows.UpAndDown)
        {
            Items.Sort((x, y) => getProp(x).CompareTo(getProp(y)));
            _headerSort[headearId] = SortArrows.Up;
        }
        else
        {
            Items.Sort((x, y) => getProp(y).CompareTo(getProp(x)));
            _headerSort[headearId] = SortArrows.Down;
        }
        for (int i = 0; i < PropertiesList.Count; i++)
        {
            if (i != headearId)
            {
                _headerSort[i] = SortArrows.UpAndDown;
            }
        }
        _rowCount = 0;
    }

    private string GetSortedByArrow(SortArrows sortArrows)
    {
        if (sortArrows == SortArrows.Up) return "↑";
        else if (sortArrows == SortArrows.Down) return "↓";
        else return "↑↓";
    }

    private enum SortArrows
    {
        Up,
        Down,
        UpAndDown
    }

    private int _rowCount { get; set; }

    [Parameter]
    public bool UseRowCount { get; set; }

    [Parameter]
    public string TableClass { get; set; }

    [Parameter]
    public string HeaderClass { get; set; }

    [Parameter]
    public RenderFragment<TItem> RowTemplate { get; set; }

    [Parameter]
    public RenderFragment TableFooter { get; set; }

    [Parameter]
    public List<TItem> Items { get; set; }
}